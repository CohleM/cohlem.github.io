<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>RoPE | CohleM</title>
<meta name="keywords" content="">
<meta name="description" content="Recap of Absolute PE We previously used absolute positional embedding in our GPT-2 model.
Disadvantages No notion of relative information between tokens doesn&rsquo;t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length. RoPE pre-requisites This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE.">
<meta name="author" content="CohleM">
<link rel="canonical" href="https://cohlem.github.io/sub-notes/rope/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://cohlem.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cohlem.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cohlem.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cohlem.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cohlem.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X6LV4QY2G2"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-X6LV4QY2G2', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="RoPE" />
<meta property="og:description" content="Recap of Absolute PE We previously used absolute positional embedding in our GPT-2 model.
Disadvantages No notion of relative information between tokens doesn&rsquo;t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length. RoPE pre-requisites This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cohlem.github.io/sub-notes/rope/" /><meta property="article:section" content="sub-notes" />
<meta property="article:published_time" content="2025-01-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2025-01-15T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RoPE"/>
<meta name="twitter:description" content="Recap of Absolute PE We previously used absolute positional embedding in our GPT-2 model.
Disadvantages No notion of relative information between tokens doesn&rsquo;t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length. RoPE pre-requisites This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Sub-notes",
      "item": "https://cohlem.github.io/sub-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "RoPE",
      "item": "https://cohlem.github.io/sub-notes/rope/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RoPE",
  "name": "RoPE",
  "description": "Recap of Absolute PE We previously used absolute positional embedding in our GPT-2 model.\nDisadvantages No notion of relative information between tokens doesn\u0026rsquo;t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length. RoPE pre-requisites This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE.",
  "keywords": [
    
  ],
  "articleBody": "Recap of Absolute PE We previously used absolute positional embedding in our GPT-2 model.\nDisadvantages No notion of relative information between tokens doesn’t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length. RoPE pre-requisites This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE.\nIn RoPE, the notion of providing a position to a token is by rotating it by some angle. For instance, if we have a token “this” with an embedding of 2 i.e [0.2782, 1.5109] and lets say it occurs in our sequence at first\n[this,is,awesome] The idea is to rotate token’s embedding according to the position it occurs in our sequence.\nFor instance, if this occurs in 2nd position it’s original embedding ([0.2782, 1.5109]) will be rotated by some angle m x theta, where m is the position and theta is some angle. You can see how we’re incorporating information about absolute position of tokens (m) while rotating it.\nbut the embedding is usually bigger than what we’ve assumed here, it’s basically 256,512,768 depending on what we choose. Let’s say we have embedding dimension of 4 for the sake of simplicity. The idea is to first divide embedding dimensions into pairs and apply rotation to each pairs.\nd_model = 4 sentence = 'this is awesome' x = [i for i in range(len(sentence.split(' ')))] Q = torch.randn(len(sequence), d_model) Q output\n[[ 0.2782, 1.5109, 0.1739, -0.7098], [ 0.3792, -0.1098, 0.3707, -0.4049], [ 0.1652, 0.5787, 0.4085, -0.7005]] so embedding for our token “this” corresponds to\n[ 0.2782, 1.5109, 0.1739, -0.7098] it is divided into two i.e i values i.e i = 0 will correspond to [ 0.2782, 1.5109] and i=1 will correspond to[0.1739, -0.7098] so, the i values ranges from 0 to d_model/2 - 1, where d_model is the embedding dimension and and we can apply rotation to each of these separately and combine them together into one single embedding.\nthe angle by which we rotate a pair depends on m and theta, as m is simply the position and theta is generally this\n10000 ** (-2 * i / d_model) #where i corresponds to each pair as described above. let’s see how embedding of our token “this” is rotated if it occurs at different positions (i.e different m) in this case i’m assuming i=0 (only considering the first pair)\nWe construct our rotation matrix like this\ndef rotation_matrix(m, i, d_model): \"\"\" Compute the 2x2 rotation matrix for RoPE. Args: m (int or torch.Tensor): Position (token index). i (int or torch.Tensor): Dimension index. d_model (int): Embedding dimension. Returns: torch.Tensor: 2x2 rotation matrix. \"\"\" # Compute theta_i thetai = 10000 ** (-2 * i / d_model) print(thetai) # Ensure m is a tensor m = torch.tensor(m, dtype=torch.float32) # Compute cos(m * theta_i) and sin(m * theta_i) angle = m * thetai cos = torch.cos(angle) sin = torch.sin(angle) # Construct the 2x2 rotation matrix rotation_matrix = torch.tensor([ [cos, -sin], [sin, cos] ]) return rotation_matrix and apply this rotation for different m values(different positions) i.e 1,2,3,4,5\n# Input vector inp = Q[0,:2].detach().numpy() # [ 0.2782, 1.5109] # Create a figure and axis plt.figure() # Draw the coordinate axes plt.axhline(0, color=\"black\", linewidth=1) # X-axis plt.axvline(0, color=\"black\", linewidth=1) # Y-axis # Set axis limits plt.xlim(-2, 2) plt.ylim(-2, 2) # Plot the original input vector plt.plot([0, inp[0]], [0, inp[1]], color='blue', label='Original', marker='o') # Apply rotation and plot the rotated vectors for m in range(1, 5): # Compute the rotation matrix rot_mat = rotation_matrix(m, 0, d_model) # Apply the rotation to the input vector ans = rot_mat @ inp # Plot the rotated vector print(ans) plt.plot([0, ans[0]], [0, ans[1]], label=f'Rotated (m={m})', marker='o') # Add labels and title plt.xlabel(\"X-axis\") plt.ylabel(\"Y-axis\") plt.title(\"RoPE Rotation Visualization\") # Add a legend plt.legend() # Add a grid plt.grid(True, linestyle=\"--\", alpha=0.7) # Display the plot plt.show() you can see how these are rotated by some big angles when m is changed.\nbut this isn’t the case for later embedding pairs (i.e i = 300, when d_model = 768).\nThe more we increase our i values the less angle it will rotate with. Lets see one example I’m keeping the value of m as a constant i.e 1 here and plotting for different i values for sample input embedding.\ninp = Q[0,:2].detach().numpy() # Create a figure and axis plt.figure() # Draw the coordinate axes plt.axhline(0, color=\"black\", linewidth=1) # X-axis plt.axvline(0, color=\"black\", linewidth=1) # Y-axis # Set axis limits plt.xlim(-2, 2) plt.ylim(-2, 2) # Plot the original input vector plt.plot([0, inp[0]], [0, inp[1]], color='blue', label='Original', marker='o') #Apply rotation and plot the rotated vectors for i in range(1, 20): # Compute the rotation matrix rot_mat = rotation_matrix(1,i , 40) # Apply the rotation to the input vector ans = rot_mat @ inp # Plot the rotated vector print(ans) plt.plot([0, ans[0]], [0, ans[1]], label=f'Rotated i={i} (m={0})', marker='o') # Add labels and title plt.xlabel(\"X-axis\") plt.ylabel(\"Y-axis\") plt.title(\"RoPE Rotation Visualization\") # Add a legend plt.legend() # Add a grid plt.grid(True, linestyle=\"--\", alpha=0.7) # Display the plot plt.show() as you can see the angle between them becomes smaller and smaller when I is increased.\nNOTE: In the figure above our original plot (dark blue) lies in the same pos as the plot covered by i=19.\nI just wanted to show how angles change depending on m and i values.\nNow that we have basic intuition, lets implement it.\nrotating a embedding of dimension 2 is simple, but how do we do it for more than 2 dimension in just one operation?\nhere’s how. we construct matrix like this where the diagonal is rotation matrix (same matrix that we used above) and all the other elements are sparse i.e 0 and then multiply this big rotation matrix with our embedding of size d.\nBut the authors of this paper have derived a simple formula for doing the same operation but without the big matrix, because it would be computationally expensive where most of the elements are sparse.\nhere’s the simplified formula. lets apply this simplified version to our token “this” where it’s embedding is [ 0.2782, 1.5109, 0.1739, -0.7098]\nNOTE: this code below only applies the rotation to token “this” only for simplicity. m=0 because it occurs at position 0.\nIf you take a closer look the code below, it matches the formula shown above.\nm = 0 cos_dim = [math.cos(m*(10000**(-2*i/d_model))) for i in range(d_model//2) for _ in range(2)] sin_dim = [math.sin(m*(10000**(-2*i/d_model))) for i in range(d_model//2) for _ in range(2)] QT = torch.empty_like(Q[0]) QT[1::2] = Q[0][::2] QT[::2] = -Q[0][1::2] simplified_ans = Q[0]*torch.tensor(cos_dim) + QT*torch.tensor(sin_dim) # using m This code below applies the rotation to all 3 tokens in our sequence for all i values.\nthetai = 1.0 / (10000 ** (2*torch.arange(0, d_model//2).float() / d_model)) m = torch.arange(Q.shape[0], dtype=torch.float) sinusoid = m.unsqueeze(1) * thetai.unsqueeze(0) # Outer product freq = sinusoid.repeat_interleave(2,dim=1) cos= torch.cos(freq) sin = torch.sin(freq) Q_new = torch.empty_like(Q) Q_new[:,::2] = -Q[:,1::2] Q_new[:,1::2] = Q[:,::2] ans = Q*cos + Q_new*sin all these code were for matrix rotation. But there’s more to it.\nllama models don’t use these type of operation, because there seems to be too much tensor manipulation is a bit computationally expensive. There seems to be an elegant way of doing 2D rotation, and that is by using complex numbers.\nBefore going into the implementation, please read these paper notes.\nComplex plane is simply representing real numbers along the x-axis and imaginary numbers along y (i.e imaginary plane is perpendicular to the real plane)\nafter completely understanding the notes, now we you may have the notion that we can represent our embedding in complex numbers and then multiply by cos(theta) +i.sin(theta) to rotate it by theta.\nwhat we do now in the code below is represent our input in complex form, and represent the rotation angles in polar form and then multiply together to get the output.\ndef precompute_freq_cis(dim, end, theta = 10000): thetai = 1.0 / (theta ** (torch.arange(0, dim, 2)[: (dim // 2)].float() / dim)) m = torch.arange(end, device=thetai.device) mthetai = torch.outer(m,thetai) # m x thetai return torch.polar(torch.ones_like(mthetai),mthetai) # computes r * e^mthetai def apply_rotary_pe(xq, xk, cis): def unite_shape(pos_cis, x): ndim = x.ndim assert 0 \u003c= 1 \u003c ndim assert pos_cis.shape == (x.shape[1], x.shape[-1]) shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)] return pos_cis.view(*shape) xq_ = torch.view_as_complex(xq.view(*xq.shape[:-1],-1,2)) # converting to complex form xk_ = torch.view_as_complex(xk.view(*xq.shape[:-1],-1,2)) # converting to complex form cis = unite_shape(cis,xq_) xq_out = torch.view_as_real(xq_ * cis).flatten(3) xk_out = torch.view_as_real(xk_ * cis).flatten(3) return xq_out.type_as(xq), xk_out.type_as(xk) freq_cis = precompute_freq_cis(4,3) xq = torch.randn(5,3,2,4) xk = torch.randn(5,3,2,4) xq_out, xk_out = apply_rotary_pe(xq,xk,freq_cis) This is how it’s originally implemented in llama models as you can see here\nhttps://github.com/meta-llama/llama/blob/8fac8befd776bc03242fe7bc2236cdb41b6c609c/llama/model.py#L132\nReferences https://arxiv.org/pdf/2104.09864 RoPE Complex Numbers Fundamentals llama code implementation ",
  "wordCount" : "1470",
  "inLanguage": "en",
  "datePublished": "2025-01-15T00:00:00Z",
  "dateModified": "2025-01-15T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "CohleM"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cohlem.github.io/sub-notes/rope/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CohleM",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cohlem.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cohlem.github.io" accesskey="h" title="CohleM (Alt + H)">CohleM</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://cohlem.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://cohlem.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://cohlem.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://cohlem.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://cohlem.github.io">Home</a>&nbsp;»&nbsp;<a href="https://cohlem.github.io/sub-notes/">Sub-notes</a></div>
    <h1 class="post-title">
      RoPE
    </h1>
    <div class="post-meta"><span title='2025-01-15 00:00:00 +0000 UTC'>January 15, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;CohleM

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#recap-of-absolute-pe" aria-label="Recap of Absolute PE">Recap of Absolute PE</a><ul>
                        
                <li>
                    <a href="#disadvantages" aria-label="Disadvantages">Disadvantages</a></li></ul>
                </li>
                <li>
                    <a href="#rope" aria-label="RoPE">RoPE</a><ul>
                        
                <li>
                    <a href="#pre-requisites" aria-label="pre-requisites">pre-requisites</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="recap-of-absolute-pe">Recap of Absolute PE<a hidden class="anchor" aria-hidden="true" href="#recap-of-absolute-pe">#</a></h3>
<p>We previously used absolute positional embedding in our GPT-2 model.</p>
<h4 id="disadvantages">Disadvantages<a hidden class="anchor" aria-hidden="true" href="#disadvantages">#</a></h4>
<ul>
<li>No notion of relative information between tokens</li>
<li>doesn&rsquo;t work for sequences larger than context length the model is trained with, because we run out of token embeddings for tokens that come at sequence larger than the context length.</li>
</ul>
<h3 id="rope">RoPE<a hidden class="anchor" aria-hidden="true" href="#rope">#</a></h3>
<h4 id="pre-requisites">pre-requisites<a hidden class="anchor" aria-hidden="true" href="#pre-requisites">#</a></h4>
<p><img loading="lazy" src="rope1.png" alt="rope1"  />
</p>
<p>This is how we rotate a point by an angel theta in a two dimensional space and this is all we need in RoPE.</p>
<p>In RoPE, the notion of providing a position to a token is by rotating it by some angle.
For instance, if  we have a token &ldquo;this&rdquo; with an embedding of 2 i.e [0.2782,  1.5109] and lets say it occurs in our sequence at first</p>
<pre tabindex="0"><code>[this,is,awesome]
</code></pre><p>The idea is to rotate token&rsquo;s embedding according to the position it occurs in our sequence.</p>
<p>For instance, if this occurs in 2nd position it&rsquo;s original embedding ([0.2782,  1.5109]) will be rotated by some angle m x theta, where m is the position and theta is some angle. You can see how we&rsquo;re incorporating information about absolute position of tokens (m) while rotating it.</p>
<p>but the embedding is usually bigger than what we&rsquo;ve assumed here, it&rsquo;s basically 256,512,768 depending on what we choose. Let&rsquo;s say we have embedding dimension of 4 for the sake of simplicity. The idea is to first divide embedding dimensions into pairs and apply rotation to each pairs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>d_model <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>sentence <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;this is awesome&#39;</span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(sentence<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; &#39;</span>)))]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Q <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>randn(len(sequence), d_model)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Q
</span></span></code></pre></div><p>output</p>
<pre tabindex="0"><code>		[[ 0.2782,  1.5109,  0.1739, -0.7098],
        [ 0.3792, -0.1098,  0.3707, -0.4049],
        [ 0.1652,  0.5787,  0.4085, -0.7005]]
</code></pre><p>so embedding for our token &ldquo;this&rdquo; corresponds to</p>
<pre tabindex="0"><code>[ 0.2782,  1.5109,  0.1739, -0.7098]
</code></pre><p>it is divided into two i.e i values i.e i = 0 will correspond to [ 0.2782,  1.5109] and  i=1 will correspond to[0.1739, -0.7098] so, the i values ranges from 0 to d_model/2 - 1, where d_model is the embedding dimension and and we can apply rotation to each of these separately and combine them together into one single embedding.</p>
<p>the angle by which we rotate a pair depends on m and theta, as m is simply the position and theta is generally this</p>
<pre tabindex="0"><code>10000 ** (-2 * i / d_model) #where i corresponds to each pair as described above.
</code></pre><p>let&rsquo;s see how embedding of our token &ldquo;this&rdquo; is rotated if it occurs at different positions (i.e different m) in this case i&rsquo;m assuming i=0 (only considering the first pair)</p>
<p>We construct our rotation matrix like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rotation_matrix</span>(m, i, d_model):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Compute the 2x2 rotation matrix for RoPE.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        m (int or torch.Tensor): Position (token index).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i (int or torch.Tensor): Dimension index.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        d_model (int): Embedding dimension.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        torch.Tensor: 2x2 rotation matrix.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute theta_i</span>
</span></span><span style="display:flex;"><span>    thetai <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span> <span style="color:#f92672">**</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">/</span> d_model)
</span></span><span style="display:flex;"><span>    print(thetai)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Ensure m is a tensor</span>
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>tensor(m, dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float32)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute cos(m * theta_i) and sin(m * theta_i)</span>
</span></span><span style="display:flex;"><span>    angle <span style="color:#f92672">=</span> m <span style="color:#f92672">*</span> thetai
</span></span><span style="display:flex;"><span>    cos <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cos(angle)
</span></span><span style="display:flex;"><span>    sin <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>sin(angle)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construct the 2x2 rotation matrix</span>
</span></span><span style="display:flex;"><span>    rotation_matrix <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>tensor([
</span></span><span style="display:flex;"><span>        [cos, <span style="color:#f92672">-</span>sin],
</span></span><span style="display:flex;"><span>        [sin, cos]
</span></span><span style="display:flex;"><span>    ])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rotation_matrix
</span></span></code></pre></div><p>and apply this rotation for different m values(different positions) i.e 1,2,3,4,5</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Input vector</span>
</span></span><span style="display:flex;"><span>inp <span style="color:#f92672">=</span> Q[<span style="color:#ae81ff">0</span>,:<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>numpy() <span style="color:#75715e"># [ 0.2782,  1.5109]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a figure and axis</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Draw the coordinate axes</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># X-axis</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># Y-axis</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set axis limits</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the original input vector</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([<span style="color:#ae81ff">0</span>, inp[<span style="color:#ae81ff">0</span>]], [<span style="color:#ae81ff">0</span>, inp[<span style="color:#ae81ff">1</span>]], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Original&#39;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Apply rotation and plot the rotated vectors</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute the rotation matrix</span>
</span></span><span style="display:flex;"><span>    rot_mat <span style="color:#f92672">=</span> rotation_matrix(m, <span style="color:#ae81ff">0</span>, d_model)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Apply the rotation to the input vector</span>
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> rot_mat <span style="color:#f92672">@</span> inp
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Plot the rotated vector</span>
</span></span><span style="display:flex;"><span>    print(ans)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot([<span style="color:#ae81ff">0</span>, ans[<span style="color:#ae81ff">0</span>]], [<span style="color:#ae81ff">0</span>, ans[<span style="color:#ae81ff">1</span>]], label<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Rotated (m=</span><span style="color:#e6db74">{</span>m<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#39;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add labels and title</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;X-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Y-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;RoPE Rotation Visualization&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add a legend</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add a grid</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Display the plot</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img loading="lazy" src="rope2.png" alt="rope2"  />
</p>
<p>you can see how these are rotated by some big angles when m is changed.</p>
<p>but this isn&rsquo;t the case for later embedding pairs (i.e i = 300, when d_model = 768).</p>
<p>The more we increase our i values the less angle it will rotate with. Lets see one example
I&rsquo;m keeping the value of m as a constant i.e 1 here and plotting for different i values for sample input embedding.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>inp <span style="color:#f92672">=</span> Q[<span style="color:#ae81ff">0</span>,:<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a figure and axis</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Draw the coordinate axes</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># X-axis</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># Y-axis</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set axis limits</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the original input vector</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([<span style="color:#ae81ff">0</span>, inp[<span style="color:#ae81ff">0</span>]], [<span style="color:#ae81ff">0</span>, inp[<span style="color:#ae81ff">1</span>]], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Original&#39;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Apply rotation and plot the rotated vectors</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute the rotation matrix</span>
</span></span><span style="display:flex;"><span>    rot_mat <span style="color:#f92672">=</span> rotation_matrix(<span style="color:#ae81ff">1</span>,i , <span style="color:#ae81ff">40</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Apply the rotation to the input vector</span>
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> rot_mat <span style="color:#f92672">@</span> inp
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Plot the rotated vector</span>
</span></span><span style="display:flex;"><span>    print(ans)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot([<span style="color:#ae81ff">0</span>, ans[<span style="color:#ae81ff">0</span>]], [<span style="color:#ae81ff">0</span>, ans[<span style="color:#ae81ff">1</span>]], label<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Rotated i=</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74"> (m=</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)&#39;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add labels and title</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;X-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Y-axis&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;RoPE Rotation Visualization&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add a legend</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add a grid</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Display the plot</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img loading="lazy" src="rope3.png" alt="ropee3"  />
</p>
<p>as you can see the angle between them becomes smaller and smaller when I is increased.</p>
<p>NOTE: In the figure above our original plot (dark blue) lies in the same pos as the plot covered by i=19.</p>
<p>I just wanted to show how angles change depending on m and i values.</p>
<p>Now that we have basic intuition, lets implement it.</p>
<p>rotating a embedding of dimension 2 is simple, but how do we do it for more than 2 dimension in just one operation?</p>
<p>here&rsquo;s how.
<img loading="lazy" src="rope4.png" alt="rope4"  />

we construct matrix like this where the diagonal is rotation matrix (same matrix that we used above) and all the other elements are sparse i.e 0 and then multiply this big rotation matrix with our embedding of size d.</p>
<p>But the authors of this paper have derived a simple formula for doing the same operation but without the big matrix, because it would be computationally expensive where most of the elements are sparse.</p>
<p>here&rsquo;s the simplified formula.
<img loading="lazy" src="rope5.png" alt="rope5"  />
</p>
<p>lets apply this simplified version to our token &ldquo;this&rdquo; where it&rsquo;s embedding is [ 0.2782,  1.5109,  0.1739, -0.7098]</p>
<p>NOTE: this code below only applies the rotation to token &ldquo;this&rdquo; only for simplicity. m=0 because it occurs at position 0.</p>
<p>If you take a closer look the code below, it matches the formula shown above.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>cos_dim <span style="color:#f92672">=</span> [math<span style="color:#f92672">.</span>cos(m<span style="color:#f92672">*</span>(<span style="color:#ae81ff">10000</span><span style="color:#f92672">**</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i<span style="color:#f92672">/</span>d_model))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(d_model<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>)]
</span></span><span style="display:flex;"><span>sin_dim <span style="color:#f92672">=</span> [math<span style="color:#f92672">.</span>sin(m<span style="color:#f92672">*</span>(<span style="color:#ae81ff">10000</span><span style="color:#f92672">**</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i<span style="color:#f92672">/</span>d_model))) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(d_model<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QT <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>empty_like(Q[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QT[<span style="color:#ae81ff">1</span>::<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> Q[<span style="color:#ae81ff">0</span>][::<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>QT[::<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>Q[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>::<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>simplified_ans <span style="color:#f92672">=</span> Q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>torch<span style="color:#f92672">.</span>tensor(cos_dim) <span style="color:#f92672">+</span> QT<span style="color:#f92672">*</span>torch<span style="color:#f92672">.</span>tensor(sin_dim) <span style="color:#75715e"># using m</span>
</span></span></code></pre></div><p>This code below applies the rotation to all 3 tokens in our sequence for all i values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>thetai <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">10000</span> <span style="color:#f92672">**</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>torch<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">0</span>, d_model<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>float() <span style="color:#f92672">/</span> d_model))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>arange(Q<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>], dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float)
</span></span><span style="display:flex;"><span>sinusoid <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> thetai<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">0</span>)  <span style="color:#75715e"># Outer product</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>freq <span style="color:#f92672">=</span> sinusoid<span style="color:#f92672">.</span>repeat_interleave(<span style="color:#ae81ff">2</span>,dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cos<span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cos(freq)
</span></span><span style="display:flex;"><span>sin <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>sin(freq)
</span></span><span style="display:flex;"><span>Q_new <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>empty_like(Q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Q_new[:,::<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>Q[:,<span style="color:#ae81ff">1</span>::<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>Q_new[:,<span style="color:#ae81ff">1</span>::<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> Q[:,::<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ans <span style="color:#f92672">=</span> Q<span style="color:#f92672">*</span>cos <span style="color:#f92672">+</span> Q_new<span style="color:#f92672">*</span>sin
</span></span></code></pre></div><p>all these code were for matrix rotation. But there&rsquo;s more to it.</p>
<p>llama models don&rsquo;t use these type of operation, because there seems to be too much tensor manipulation is a bit computationally expensive. There seems to be an elegant way of doing 2D rotation, and that is by using complex numbers.</p>
<p>Before going into the implementation, please read these paper notes.</p>
<p>Complex plane is simply representing real numbers along the x-axis and imaginary numbers along y (i.e imaginary plane is perpendicular to the real plane)</p>
<p><img loading="lazy" src="rope6.jpg" alt="rope6"  />

<img loading="lazy" src="rope7.jpg" alt="rope7"  />

<img loading="lazy" src="rope8.jpg" alt="rope8"  />
</p>
<p>after completely understanding the notes, now we you may have the notion that we can represent our embedding in complex numbers and then multiply by cos(theta) +i.sin(theta)
to rotate it by theta.</p>
<p>what we do now in the code below is represent our input in complex form, and represent the rotation angles in polar form and then multiply together to get the output.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">precompute_freq_cis</span>(dim, end, theta <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    thetai <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (theta <span style="color:#f92672">**</span> (torch<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">0</span>, dim, <span style="color:#ae81ff">2</span>)[: (dim <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)]<span style="color:#f92672">.</span>float() <span style="color:#f92672">/</span> dim)) 
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>arange(end, device<span style="color:#f92672">=</span>thetai<span style="color:#f92672">.</span>device)
</span></span><span style="display:flex;"><span>    mthetai <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>outer(m,thetai) <span style="color:#75715e"># m x thetai</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> torch<span style="color:#f92672">.</span>polar(torch<span style="color:#f92672">.</span>ones_like(mthetai),mthetai) <span style="color:#75715e"># computes r * e^mthetai</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">apply_rotary_pe</span>(xq, xk, cis):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">unite_shape</span>(pos_cis, x):
</span></span><span style="display:flex;"><span>        ndim <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>ndim
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> ndim
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> pos_cis<span style="color:#f92672">.</span>shape <span style="color:#f92672">==</span> (x<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>], x<span style="color:#f92672">.</span>shape[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        shape <span style="color:#f92672">=</span> [d <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">==</span> ndim <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> i, d <span style="color:#f92672">in</span> enumerate(x<span style="color:#f92672">.</span>shape)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pos_cis<span style="color:#f92672">.</span>view(<span style="color:#f92672">*</span>shape)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    xq_ <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>view_as_complex(xq<span style="color:#f92672">.</span>view(<span style="color:#f92672">*</span>xq<span style="color:#f92672">.</span>shape[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)) <span style="color:#75715e"># converting to complex form</span>
</span></span><span style="display:flex;"><span>    xk_ <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>view_as_complex(xk<span style="color:#f92672">.</span>view(<span style="color:#f92672">*</span>xq<span style="color:#f92672">.</span>shape[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)) <span style="color:#75715e"># converting to complex form</span>
</span></span><span style="display:flex;"><span>    cis <span style="color:#f92672">=</span> unite_shape(cis,xq_)
</span></span><span style="display:flex;"><span>    xq_out <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>view_as_real(xq_ <span style="color:#f92672">*</span> cis)<span style="color:#f92672">.</span>flatten(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    xk_out <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>view_as_real(xk_ <span style="color:#f92672">*</span> cis)<span style="color:#f92672">.</span>flatten(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> xq_out<span style="color:#f92672">.</span>type_as(xq), xk_out<span style="color:#f92672">.</span>type_as(xk)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>freq_cis <span style="color:#f92672">=</span> precompute_freq_cis(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>xq <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>randn(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>xk <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>randn(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xq_out, xk_out <span style="color:#f92672">=</span> apply_rotary_pe(xq,xk,freq_cis)
</span></span></code></pre></div><p>This is how it&rsquo;s originally implemented in llama models as you can see here</p>
<p><a href="https://github.com/meta-llama/llama/blob/8fac8befd776bc03242fe7bc2236cdb41b6c609c/llama/model.py#L132">https://github.com/meta-llama/llama/blob/8fac8befd776bc03242fe7bc2236cdb41b6c609c/llama/model.py#L132</a></p>
<h3 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<ul>
<li><a href="https://arxiv.org/pdf/2104.09864">https://arxiv.org/pdf/2104.09864</a></li>
<li><a href="https://youtu.be/GQPOtyITy54?si=VBH6Vnnsykmv9BaQ">RoPE</a></li>
<li><a href="https://www.youtube.com/watch?v=5PcpBw5Hbwo">Complex Numbers Fundamentals</a></li>
<li><a href="https://github.com/meta-llama/llama/tree/main">llama code implementation</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://cohlem.github.io/sub-notes/rmsnorm/">
    <span class="title">« Prev</span>
    <br>
    <span>RMSNorm</span>
  </a>
  <a class="next" href="https://cohlem.github.io/sub-notes/gpus/">
    <span class="title">Next »</span>
    <br>
    <span>GPUs</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://cohlem.github.io">CohleM</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
