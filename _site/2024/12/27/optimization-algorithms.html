<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimization Algorithms - </title>
    <link rel="stylesheet" href="/assets/css/main.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&family=Zalando+Sans:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />

    <!-- MathJax for LaTeX -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
          processEnvironments: true,
        },
        options: {
          skipHtmlTags: ["script", "noscript", "style", "textarea", "pre"],
        },
      };
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
      id="MathJax-script"
      async
    ></script>
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <a href="/posts">Posts</a>
      <a href="/notes">Notes</a>
      <a href="/blogs">Blogs</a>
    </nav>

    <main><h1>Optimization Algorithms</h1>
<p>27 Dec 2024 - cohlem</p>

<p>The simplest algorithm is the gradient descent in which we simply calculate loss over all the training data and then update our parameters, but it would be too slow and would consume too much resources. A faster approach is to use SGD where we calculate loss over every single training data and then do the parameter update, but the gradient update could be fuzzy. A more robust approach is to do mini batch SGD.</p>

<p>There are different types of optimizers with distinct capabilities.</p>

<h3 id="sgd-with-momentum">SGD with momentum</h3>

<p>We have one addition in this optimizer i.e velocity term, it accumulates the velocity of previous gradient and move forward with that momentum. I’ve tried to see how it builds up velocity in the image below. As we can see gradient update depends not only on it’s current gradient but also it’s previous weights which provide the instance (t+1) with some momentum i.e gradient from previous steps (t, t-1, t-2 and so on). As we move towards higher iterations (t=100000) the effect of initial gradients i.e t=0, t=1 and so on becomes 0 because beta term is raised to the power t=100000, and only the closest gradients are fully taken into considerations. For instance, we can see in the image below how low priority is given to the previous weights i.e 0.729 to W0, and 0.081 to W1 and so on.</p>

<h4 id="weakness">Weakness</h4>

<ul>
  <li>same learning rate is applied to all the parameters</li>
  <li>because of which the update to the parameters isn’t precise.
<img src="one.jpg" alt="one" /></li>
</ul>

<h3 id="rmsprop">RMSprop</h3>

<p>This optimizer tries to solve the problem of SGD with momentum i.e it tunes the learning rate based on it’s gradient. It sets the effect of learning rate based on it’s v term which is simply the accumulation of previous weights.</p>

<p>As you can see in the calculation done in left hand side the gradient accumulation i.e v is small so the effect of learning rate is bigger (we take bigger jumps), we take bigger jumps because we don’t want our convergence to be too slow or to stagnate, so we take bigger jumps.</p>

<p>But when the gradient accumulation i.e v term is bigger (as shown in right hand side) we take smaller steps, because in those cases if we take a big jump we might miss the global minima, so the effect of learning rate in this case is decreased.
<img src="two.jpg" alt="two" /></p>

<h3 id="adam">Adam</h3>

<p>This optimizer is simply the combination of both the momentum and RMSprop. It has its own speed determined by momentum and the learning rate adjustment provided by RMSprop.</p>

<p>The only modification is the addition of M hat and V hat i.e we scale of M and V, because initially we set the value of M and V to 0. The explanation about why we this is also provided in the image below.
<img src="three.jpg" alt="three" /></p>


<!-- <article class="blog-post">
  <header>
    <h1>Optimization Algorithms</h1>
    <time datetime="2024-12-27T00:00:00+05:45">
      December 27, 2024
    </time>
  </header>

  <div class="post-content"><p>The simplest algorithm is the gradient descent in which we simply calculate loss over all the training data and then update our parameters, but it would be too slow and would consume too much resources. A faster approach is to use SGD where we calculate loss over every single training data and then do the parameter update, but the gradient update could be fuzzy. A more robust approach is to do mini batch SGD.</p>

<p>There are different types of optimizers with distinct capabilities.</p>

<h3 id="sgd-with-momentum">SGD with momentum</h3>

<p>We have one addition in this optimizer i.e velocity term, it accumulates the velocity of previous gradient and move forward with that momentum. I’ve tried to see how it builds up velocity in the image below. As we can see gradient update depends not only on it’s current gradient but also it’s previous weights which provide the instance (t+1) with some momentum i.e gradient from previous steps (t, t-1, t-2 and so on). As we move towards higher iterations (t=100000) the effect of initial gradients i.e t=0, t=1 and so on becomes 0 because beta term is raised to the power t=100000, and only the closest gradients are fully taken into considerations. For instance, we can see in the image below how low priority is given to the previous weights i.e 0.729 to W0, and 0.081 to W1 and so on.</p>

<h4 id="weakness">Weakness</h4>

<ul>
  <li>same learning rate is applied to all the parameters</li>
  <li>because of which the update to the parameters isn’t precise.
<img src="one.jpg" alt="one" /></li>
</ul>

<h3 id="rmsprop">RMSprop</h3>

<p>This optimizer tries to solve the problem of SGD with momentum i.e it tunes the learning rate based on it’s gradient. It sets the effect of learning rate based on it’s v term which is simply the accumulation of previous weights.</p>

<p>As you can see in the calculation done in left hand side the gradient accumulation i.e v is small so the effect of learning rate is bigger (we take bigger jumps), we take bigger jumps because we don’t want our convergence to be too slow or to stagnate, so we take bigger jumps.</p>

<p>But when the gradient accumulation i.e v term is bigger (as shown in right hand side) we take smaller steps, because in those cases if we take a big jump we might miss the global minima, so the effect of learning rate in this case is decreased.
<img src="two.jpg" alt="two" /></p>

<h3 id="adam">Adam</h3>

<p>This optimizer is simply the combination of both the momentum and RMSprop. It has its own speed determined by momentum and the learning rate adjustment provided by RMSprop.</p>

<p>The only modification is the addition of M hat and V hat i.e we scale of M and V, because initially we set the value of M and V to 0. The explanation about why we this is also provided in the image below.
<img src="three.jpg" alt="three" /></p>
</div>

  
  <div class="tags">
    
    <span class="tag">optimization</span>
    
  </div>
  
</article> -->
</main>
  </body>
</html>
