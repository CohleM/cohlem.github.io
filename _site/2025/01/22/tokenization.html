<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tokenization - </title>
    <link rel="stylesheet" href="/assets/css/main.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&family=Zalando+Sans:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />

    <!-- MathJax for LaTeX -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
          processEnvironments: true,
        },
        options: {
          skipHtmlTags: ["script", "noscript", "style", "textarea", "pre"],
        },
      };
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
      id="MathJax-script"
      async
    ></script>
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <a href="/posts">Posts</a>
      <a href="/notes">Notes</a>
      <a href="/blogs">Blogs</a>
    </nav>

    <main><h1>Tokenization</h1>
<p>22 Jan 2025 - cohlem</p>

<h3 id="unicode">Unicode</h3>

<ul>
  <li>Character encoding standard</li>
  <li>aims to incorporate all the available digital characters</li>
  <li>Each character in Unicode has a unique 4 to 6-digit hexadecimal number. For Example, the letter ‘A’ has the code 0041, represented as U+0041.</li>
  <li>compatible with ASCII</li>
  <li>first 128 characters in Unicode directly correspond to the characters represented in the 7-bit ASCII table</li>
</ul>

<h3 id="unicode-transformation-format-utf-8">Unicode Transformation Format (UTF-8)</h3>

<ul>
  <li>uses 1-4 bytes to represent each character</li>
  <li>can encode all the unicode code points</li>
  <li>backward compatible with ASCII</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Example:
(1 byte) The character 'A' (U+0041) is encoded as `01000001` (0x41 in hexadecimal).
(2 byte) The character '¢' (U+00A2) is encoded as `11000010 10100010` (0xC2 0xA2 in hexadecimal).
(3 byte) The character '€' (U+20AC) is encoded as `11100010 10000010 10101100` (0xE2 0x82 0xAC in hexadecimal).
(4 byte) The character '𠜎' (U+2070E) is encoded as `11110000 10100000 10011100 10001110`(0xF0 0xA0 0x9C 0x8E in hexadecimal).

</code></pre></div></div>

<p>let’s understand some difference between unicode and utf-8
character ‘€’ has</p>

<p>unicode code point (hex): U+20AC
unicode code point (decimal): 8364</p>

<p>So there is a single number (decimal) that represents characters in unicode</p>

<p>but, the same character in utf-8 is represented as</p>

<ul>
  <li><strong>Binary</strong>: <code class="language-plaintext highlighter-rouge">11100010 10000010 10101100</code></li>
  <li><strong>Hexadecimal:</strong> <code class="language-plaintext highlighter-rouge">0xE2 0x82 0xAC</code></li>
  <li><strong>Decimal:</strong> <code class="language-plaintext highlighter-rouge">226, 130, 172</code></li>
</ul>

<p>Why ? utf-8 is a standard that stores characters in 1-4 bytes as described above.</p>

<p>similarly in python, we can get it’s hex values by <code class="language-plaintext highlighter-rouge">'€'.encode('utf-8')</code> and converting it to list gives us it’s list of decimal values and doing <code class="language-plaintext highlighter-rouge">ord(</code>‘€’) gives us it’s unicode code point in decimal`</p>

<h3 id="build-vocabulary">Build vocabulary</h3>

<p>We build our vocabulary by gathering chunks of bytes that appear together most of the times,</p>

<p>Suppose the data to be encoded is</p>

<p><code class="language-plaintext highlighter-rouge">aaabdaaabac</code></p>

<p>the byte pair “aa” occurs most often, so it will be replaced by a byte that is not used in the data, such as “Z”. Now there is the following data and replacement table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZabdZabac
Z=aa
</code></pre></div></div>

<p>Then the process is repeated with byte pair “ab”, replacing it with “Y”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZYdZYac
Y=ab
Z=aa
</code></pre></div></div>

<p>again, the pair ZY occurs twice so our data and replacement table becomes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XdXac
X=ZY
Y=ab
Z=aa
</code></pre></div></div>

<p>We now write code to implement this same functionality.</p>

<p>The function below constructs a dictionary that keeps track of frequency of bytes that come together.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">freq</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">.</span><span class="nf">get</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">freq</span>
</code></pre></div></div>

<p>This merge function is now used to merge the two bytes into one. similar to Z=aa in the example above.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="n">n_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">n_ids</span>
</code></pre></div></div>

<p>We do this iteratively for <code class="language-plaintext highlighter-rouge">total_merges</code> times,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">max_vocab</span> <span class="o">=</span> <span class="mi">356</span>
<span class="n">total_merges</span> <span class="o">=</span> <span class="n">max_vocab</span> <span class="o">-</span> <span class="mi">256</span>
<span class="n">merge_dict</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">total_merges</span><span class="p">):</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">pair</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">stats</span><span class="p">.</span><span class="n">get</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">256</span><span class="o">+</span><span class="n">i</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">text_utf8</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">merge_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

</code></pre></div></div>

<h3 id="encode">Encode</h3>

<p>lets encode our text into our tokens using our merge_dict which keeps track of all the possible combination of characters.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="c1"># given a string, return list of integers (the tokens)
</span>    <span class="n">tokens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">))</span>
    <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">merge_dict</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merges</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># nothing else can be merged
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">merge_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span>


</code></pre></div></div>

<p>here we need to be careful about how we encode the tokens, i.e for instance the new 256 index in our merge_dict should be encoded first because later index for ex: 352 could be combination of 256 and 108. So we have to maintain this order.</p>

<p>to do that we first get all the token combination available to us in our dataset using stats = get_stats(tokens), and this line of code <code class="language-plaintext highlighter-rouge">pair = min(stats, key=lambda p: merges.get(p, float("inf")))</code> finds the pair with the lowest key (lets say 101,32 -&gt; 256) and then merges those 101,32 tokens to be 256 and the process is continued until there are no pairs that can be combined using our merge_dict mapping.</p>

<h3 id="decode">Decode</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vocab</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span> <span class="p">:</span> <span class="nf">bytes</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>

<span class="nf">for </span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">),</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">merge_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vocab</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vocab</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>

</code></pre></div></div>

<p>The code above maps index to its corresponding byte in utf-8, and the loop combines the byte information corresponding to their indexs, for instance lets say 256 is combo of 101,32, the bytes of 101 and 32 will be combined. lets say 352 is now a combo of 256 and 32, their byte information will be combined, which will be easier to decode the information in the code below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="sh">"</span><span class="s">replace</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>the first line in the function above maps their index to byte information, and then those utf-8 bytes will be decoded to their corresponding characters in utf-8.</p>

<p>This is the building block of tokenizer, everything that comes next is a more complex and efficient version of the tokenizer.</p>

<h3 id="openais-bpe-tokenizer">Openai’s BPE tokenizer</h3>

<p>Let’s first understand the problem our current implementation of tokenizer has.</p>

<p>It will tokenize the whole sequence. i.e lets say we have a sentence</p>

<p>I’ve chosen a bit funky sentence here, just for the purpose of explanation.</p>

<p><code class="language-plaintext highlighter-rouge">you are 52 years old, u are good too, you've achieved so much</code></p>

<p>if you look closely, this sequence of characters <code class="language-plaintext highlighter-rouge">u are</code> appear twice and will have their own mapping in the vocabulary.</p>

<p>so for token <code class="language-plaintext highlighter-rouge">u are</code> it will have one index in our vocabulary, we can see it combines characters from two separate words, which we would like to minimize, and we would like to separate out these types of tokens <code class="language-plaintext highlighter-rouge">'ve</code> because they generally go along with other words as well. For this purpose, we process our initial text through this regex.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sa">r</span><span class="sh">"""'</span><span class="s">s|</span><span class="sh">'</span><span class="s">t|</span><span class="sh">'</span><span class="s">re|</span><span class="sh">'</span><span class="s">ve|</span><span class="sh">'</span><span class="s">m|</span><span class="sh">'</span><span class="s">ll|</span><span class="sh">'</span><span class="s">d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+</span><span class="sh">"""</span><span class="p">)</span>
</code></pre></div></div>

<p>as you can see these tokens <code class="language-plaintext highlighter-rouge">s|'t|'re|'ve|'m|'ll|'d|</code> are separated from text, and we separate out words and numbers as well</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">regex</span> <span class="k">as</span> <span class="n">re</span>

<span class="n">samplere</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sa">r</span><span class="sh">"""'</span><span class="s">s|</span><span class="sh">'</span><span class="s">t|</span><span class="sh">'</span><span class="s">re|</span><span class="sh">'</span><span class="s">ve|</span><span class="sh">'</span><span class="s">m|</span><span class="sh">'</span><span class="s">ll|</span><span class="sh">'</span><span class="s">d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+</span><span class="sh">"""</span><span class="p">)</span>

<span class="n">samplere</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sh">"</span><span class="s"> you</span><span class="sh">'</span><span class="s">ve done soo much 1245234 </span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The sentence is processed in this way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[' you', "'ve", ' done', ' soo', ' much', ' 1245234', ' ']
</code></pre></div></div>

<p>and then we train our tokenizer on each elements that we get from this.</p>

<h3 id="complete-code-for-tokenizer">Complete code for tokenizer</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Tokenizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">merges</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">ids</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">freq</span>
        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

            <span class="n">freq</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">.</span><span class="nf">get</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">freq</span>


    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">n_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_ids</span>


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GPT4Pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="sh">"""'</span><span class="s">(?i:[sdmt]|ll|ve|re)|[^\r\n\p{L}\p{N}]?+\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]++[\r\n]*|\s*[\r\n]|\s+(?!\S)|\s+</span><span class="sh">"""</span>


<span class="k">class</span> <span class="nc">SampleTokenizer</span><span class="p">(</span><span class="n">Tokenizer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">max_vocab</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">GPT4Pattern</span> <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_vocab</span> <span class="o">=</span> <span class="n">max_vocab</span>
        <span class="n">self</span><span class="p">.</span><span class="n">total_merges</span> <span class="o">=</span> <span class="n">max_vocab</span> <span class="o">-</span> <span class="mi">256</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">This objective of this function is to build the merges dictionary mapping and build vocab</span><span class="sh">"""</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="n">ch</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">))</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>


        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">total_merges</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">p</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">get_stats</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

            <span class="n">pair</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">freq</span><span class="p">.</span><span class="n">get</span><span class="p">)</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>

            <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">_build_vocab</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_vocab</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span> <span class="p">:</span> <span class="nf">bytes</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">),</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># given a string, return list of integers (the tokens)
</span>        <span class="n">tokens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">))</span>
        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_stats</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># nothing else can be merged
</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">ids</span><span class="p">):</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="sh">"</span><span class="s">replace</span><span class="sh">"</span><span class="p">)</span>


<span class="n">st</span> <span class="o">=</span> <span class="nc">SampleTokenizer</span><span class="p">(</span><span class="mi">356</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">train</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">hey how are you doing 124</span><span class="sh">"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># outputs: 'hey how are you doing 124'
</span>
</code></pre></div></div>


<!-- <article class="blog-post">
  <header>
    <h1>Tokenization</h1>
    <time datetime="2025-01-22T00:00:00+05:45">
      January 22, 2025
    </time>
  </header>

  <div class="post-content"><h3 id="unicode">Unicode</h3>

<ul>
  <li>Character encoding standard</li>
  <li>aims to incorporate all the available digital characters</li>
  <li>Each character in Unicode has a unique 4 to 6-digit hexadecimal number. For Example, the letter ‘A’ has the code 0041, represented as U+0041.</li>
  <li>compatible with ASCII</li>
  <li>first 128 characters in Unicode directly correspond to the characters represented in the 7-bit ASCII table</li>
</ul>

<h3 id="unicode-transformation-format-utf-8">Unicode Transformation Format (UTF-8)</h3>

<ul>
  <li>uses 1-4 bytes to represent each character</li>
  <li>can encode all the unicode code points</li>
  <li>backward compatible with ASCII</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Example:
(1 byte) The character 'A' (U+0041) is encoded as `01000001` (0x41 in hexadecimal).
(2 byte) The character '¢' (U+00A2) is encoded as `11000010 10100010` (0xC2 0xA2 in hexadecimal).
(3 byte) The character '€' (U+20AC) is encoded as `11100010 10000010 10101100` (0xE2 0x82 0xAC in hexadecimal).
(4 byte) The character '𠜎' (U+2070E) is encoded as `11110000 10100000 10011100 10001110`(0xF0 0xA0 0x9C 0x8E in hexadecimal).

</code></pre></div></div>

<p>let’s understand some difference between unicode and utf-8
character ‘€’ has</p>

<p>unicode code point (hex): U+20AC
unicode code point (decimal): 8364</p>

<p>So there is a single number (decimal) that represents characters in unicode</p>

<p>but, the same character in utf-8 is represented as</p>

<ul>
  <li><strong>Binary</strong>: <code class="language-plaintext highlighter-rouge">11100010 10000010 10101100</code></li>
  <li><strong>Hexadecimal:</strong> <code class="language-plaintext highlighter-rouge">0xE2 0x82 0xAC</code></li>
  <li><strong>Decimal:</strong> <code class="language-plaintext highlighter-rouge">226, 130, 172</code></li>
</ul>

<p>Why ? utf-8 is a standard that stores characters in 1-4 bytes as described above.</p>

<p>similarly in python, we can get it’s hex values by <code class="language-plaintext highlighter-rouge">'€'.encode('utf-8')</code> and converting it to list gives us it’s list of decimal values and doing <code class="language-plaintext highlighter-rouge">ord(</code>‘€’) gives us it’s unicode code point in decimal`</p>

<h3 id="build-vocabulary">Build vocabulary</h3>

<p>We build our vocabulary by gathering chunks of bytes that appear together most of the times,</p>

<p>Suppose the data to be encoded is</p>

<p><code class="language-plaintext highlighter-rouge">aaabdaaabac</code></p>

<p>the byte pair “aa” occurs most often, so it will be replaced by a byte that is not used in the data, such as “Z”. Now there is the following data and replacement table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZabdZabac
Z=aa
</code></pre></div></div>

<p>Then the process is repeated with byte pair “ab”, replacing it with “Y”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZYdZYac
Y=ab
Z=aa
</code></pre></div></div>

<p>again, the pair ZY occurs twice so our data and replacement table becomes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XdXac
X=ZY
Y=ab
Z=aa
</code></pre></div></div>

<p>We now write code to implement this same functionality.</p>

<p>The function below constructs a dictionary that keeps track of frequency of bytes that come together.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">freq</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">.</span><span class="nf">get</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">freq</span>
</code></pre></div></div>

<p>This merge function is now used to merge the two bytes into one. similar to Z=aa in the example above.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="n">n_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">n_ids</span>
</code></pre></div></div>

<p>We do this iteratively for <code class="language-plaintext highlighter-rouge">total_merges</code> times,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">max_vocab</span> <span class="o">=</span> <span class="mi">356</span>
<span class="n">total_merges</span> <span class="o">=</span> <span class="n">max_vocab</span> <span class="o">-</span> <span class="mi">256</span>
<span class="n">merge_dict</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">total_merges</span><span class="p">):</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">pair</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">stats</span><span class="p">.</span><span class="n">get</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">256</span><span class="o">+</span><span class="n">i</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">text_utf8</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">merge_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

</code></pre></div></div>

<h3 id="encode">Encode</h3>

<p>lets encode our text into our tokens using our merge_dict which keeps track of all the possible combination of characters.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="c1"># given a string, return list of integers (the tokens)
</span>    <span class="n">tokens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">))</span>
    <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">merge_dict</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merges</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># nothing else can be merged
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">merge_dict</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span>


</code></pre></div></div>

<p>here we need to be careful about how we encode the tokens, i.e for instance the new 256 index in our merge_dict should be encoded first because later index for ex: 352 could be combination of 256 and 108. So we have to maintain this order.</p>

<p>to do that we first get all the token combination available to us in our dataset using stats = get_stats(tokens), and this line of code <code class="language-plaintext highlighter-rouge">pair = min(stats, key=lambda p: merges.get(p, float("inf")))</code> finds the pair with the lowest key (lets say 101,32 -&gt; 256) and then merges those 101,32 tokens to be 256 and the process is continued until there are no pairs that can be combined using our merge_dict mapping.</p>

<h3 id="decode">Decode</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vocab</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span> <span class="p">:</span> <span class="nf">bytes</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>

<span class="nf">for </span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">),</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">merge_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vocab</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vocab</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>

</code></pre></div></div>

<p>The code above maps index to its corresponding byte in utf-8, and the loop combines the byte information corresponding to their indexs, for instance lets say 256 is combo of 101,32, the bytes of 101 and 32 will be combined. lets say 352 is now a combo of 256 and 32, their byte information will be combined, which will be easier to decode the information in the code below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="sh">"</span><span class="s">replace</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>the first line in the function above maps their index to byte information, and then those utf-8 bytes will be decoded to their corresponding characters in utf-8.</p>

<p>This is the building block of tokenizer, everything that comes next is a more complex and efficient version of the tokenizer.</p>

<h3 id="openais-bpe-tokenizer">Openai’s BPE tokenizer</h3>

<p>Let’s first understand the problem our current implementation of tokenizer has.</p>

<p>It will tokenize the whole sequence. i.e lets say we have a sentence</p>

<p>I’ve chosen a bit funky sentence here, just for the purpose of explanation.</p>

<p><code class="language-plaintext highlighter-rouge">you are 52 years old, u are good too, you've achieved so much</code></p>

<p>if you look closely, this sequence of characters <code class="language-plaintext highlighter-rouge">u are</code> appear twice and will have their own mapping in the vocabulary.</p>

<p>so for token <code class="language-plaintext highlighter-rouge">u are</code> it will have one index in our vocabulary, we can see it combines characters from two separate words, which we would like to minimize, and we would like to separate out these types of tokens <code class="language-plaintext highlighter-rouge">'ve</code> because they generally go along with other words as well. For this purpose, we process our initial text through this regex.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sa">r</span><span class="sh">"""'</span><span class="s">s|</span><span class="sh">'</span><span class="s">t|</span><span class="sh">'</span><span class="s">re|</span><span class="sh">'</span><span class="s">ve|</span><span class="sh">'</span><span class="s">m|</span><span class="sh">'</span><span class="s">ll|</span><span class="sh">'</span><span class="s">d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+</span><span class="sh">"""</span><span class="p">)</span>
</code></pre></div></div>

<p>as you can see these tokens <code class="language-plaintext highlighter-rouge">s|'t|'re|'ve|'m|'ll|'d|</code> are separated from text, and we separate out words and numbers as well</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">regex</span> <span class="k">as</span> <span class="n">re</span>

<span class="n">samplere</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sa">r</span><span class="sh">"""'</span><span class="s">s|</span><span class="sh">'</span><span class="s">t|</span><span class="sh">'</span><span class="s">re|</span><span class="sh">'</span><span class="s">ve|</span><span class="sh">'</span><span class="s">m|</span><span class="sh">'</span><span class="s">ll|</span><span class="sh">'</span><span class="s">d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+</span><span class="sh">"""</span><span class="p">)</span>

<span class="n">samplere</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sh">"</span><span class="s"> you</span><span class="sh">'</span><span class="s">ve done soo much 1245234 </span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The sentence is processed in this way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[' you', "'ve", ' done', ' soo', ' much', ' 1245234', ' ']
</code></pre></div></div>

<p>and then we train our tokenizer on each elements that we get from this.</p>

<h3 id="complete-code-for-tokenizer">Complete code for tokenizer</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Tokenizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">merges</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">ids</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">freq</span>
        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

            <span class="n">freq</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">.</span><span class="nf">get</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">freq</span>


    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">n_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nf">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_ids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_ids</span>


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GPT4Pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="sh">"""'</span><span class="s">(?i:[sdmt]|ll|ve|re)|[^\r\n\p{L}\p{N}]?+\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]++[\r\n]*|\s*[\r\n]|\s+(?!\S)|\s+</span><span class="sh">"""</span>


<span class="k">class</span> <span class="nc">SampleTokenizer</span><span class="p">(</span><span class="n">Tokenizer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">max_vocab</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">GPT4Pattern</span> <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_vocab</span> <span class="o">=</span> <span class="n">max_vocab</span>
        <span class="n">self</span><span class="p">.</span><span class="n">total_merges</span> <span class="o">=</span> <span class="n">max_vocab</span> <span class="o">-</span> <span class="mi">256</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">This objective of this function is to build the merges dictionary mapping and build vocab</span><span class="sh">"""</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="n">ch</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">))</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>


        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">total_merges</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">p</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">get_stats</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

            <span class="n">pair</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">freq</span><span class="p">.</span><span class="n">get</span><span class="p">)</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>

            <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">_build_vocab</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_vocab</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span> <span class="p">:</span> <span class="nf">bytes</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">),</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># given a string, return list of integers (the tokens)
</span>        <span class="n">tokens</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">))</span>
        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_stats</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># nothing else can be merged
</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">merges</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">ids</span><span class="p">):</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="sh">"</span><span class="s">replace</span><span class="sh">"</span><span class="p">)</span>


<span class="n">st</span> <span class="o">=</span> <span class="nc">SampleTokenizer</span><span class="p">(</span><span class="mi">356</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">train</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">hey how are you doing 124</span><span class="sh">"</span><span class="p">)</span>
<span class="n">st</span><span class="p">.</span><span class="nf">decode</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># outputs: 'hey how are you doing 124'
</span>
</code></pre></div></div>
</div>

  
  <div class="tags">
    
  </div>
  
</article> -->
</main>

    <footer>
      <p>&copy; 2025 </p>
    </footer>
  </body>
</html>
